import type { MemoryItem, UserMemory } from "@/types/chat"

export class MemoryManager {
    private static readonly STORAGE_LIMIT = 1024 * 1024 // 1MB per user
    private static readonly MAX_MEMORIES = 200
    private static readonly IMPORTANCE_THRESHOLD = 3

    static async analyzeAndExtractMemories(
        userMessage: string,
        aiResponse: string,
        existingMemory: UserMemory | null,
        sessionId: string,
    ): Promise<MemoryItem[]> {
        try {
            const memoryExtractionPrompt = this.buildMemoryExtractionPrompt(
                userMessage,
                aiResponse,
                existingMemory?.memories || [],
            )

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${process.env.GEMINI_API_KEY}`,
                {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{ role: "user", parts: [{ text: memoryExtractionPrompt }] }],
                        generationConfig: { temperature: 0.3, maxOutputTokens: 512 },
                    }),
                },
            )

            if (!response.ok) return []

            const data = await response.json()
            const extractedText = data?.candidates?.[0]?.content?.parts?.[0]?.text || "[]"

            return this.parseAndValidateMemories(extractedText, sessionId, userMessage)
        } catch (error) {
            console.error("Error extracting memories:", error)
            return []
        }
    }

    private static buildMemoryExtractionPrompt(
        userMessage: string,
        aiResponse: string,
        existingMemories: MemoryItem[],
    ): string {
        const existingContext = existingMemories
            .slice(0, 20) // Only consider top 20 memories for context
            .map((m) => `${m.category}: ${m.content}`)
            .join("; ")

        return `Analyze this conversation and extract meaningful information about the user that should be remembered.

User: "${userMessage}"
Assistant: "${aiResponse}"

Existing memories: ${existingContext || "None"}

Extract NEW information that meets these criteria:
1. Personal preferences, goals, or characteristics
2. Important life events or circumstances  
3. Professional information or skills
4. Relationships or family details
5. Interests, hobbies, or passions
6. Learning objectives or challenges

IGNORE:
- Temporary states ("I'm tired today")
- Common pleasantries ("thank you", "hello")
- Information already captured in existing memories
- Trivial details without future relevance

Return JSON array with this exact format:
[
  {
    "content": "Specific information to remember",
    "category": "personal_info|preferences|goals|relationships|work|interests|health|education|other",
    "importance": 1-10,
    "reasoning": "Why this is worth remembering"
  }
]

Only include memories with importance >= 4. Return empty array [] if nothing significant.`
    }

    private static parseAndValidateMemories(
        extractedText: string,
        sessionId: string,
        messageContext: string,
    ): MemoryItem[] {
        try {
            const jsonMatch = extractedText.match(/\[[\s\S]*\]/)
            if (!jsonMatch) return []

            const rawMemories = JSON.parse(jsonMatch[0])
            if (!Array.isArray(rawMemories)) return []

            return rawMemories
                .filter((memory) => this.validateMemory(memory))
                .map((memory) => ({
                    id: this.generateMemoryId(),
                    content: memory.content.trim(),
                    category: memory.category,
                    importance: Math.max(1, Math.min(10, memory.importance)),
                    timestamp: new Date(),
                    autoGenerated: true,
                    sessionId,
                    messageContext: messageContext.substring(0, 200), // Store context snippet
                }))
        } catch (error) {
            console.error("Error parsing memories:", error)
            return []
        }
    }

    private static validateMemory(memory: any): boolean {
        return (
            memory &&
            typeof memory.content === "string" &&
            memory.content.length > 10 &&
            memory.content.length < 500 &&
            typeof memory.category === "string" &&
            typeof memory.importance === "number" &&
            memory.importance >= this.IMPORTANCE_THRESHOLD
        )
    }

    static optimizeMemoryStorage(memories: MemoryItem[]): MemoryItem[] {
        // Sort by importance and recency
        const sortedMemories = memories.sort((a, b) => {
            const importanceWeight = (b.importance - a.importance) * 0.7
            const recencyWeight = (b.timestamp.getTime() - a.timestamp.getTime()) * 0.3
            return importanceWeight + recencyWeight
        })

        // Remove duplicates and similar memories
        const uniqueMemories = this.removeDuplicateMemories(sortedMemories)

        // Apply storage limits
        return this.applyStorageLimits(uniqueMemories)
    }

    private static removeDuplicateMemories(memories: MemoryItem[]): MemoryItem[] {
        const seen = new Set<string>()
        return memories.filter((memory) => {
            const key = `${memory.category}:${memory.content.toLowerCase().substring(0, 50)}`
            if (seen.has(key)) return false
            seen.add(key)
            return true
        })
    }

    private static applyStorageLimits(memories: MemoryItem[]): MemoryItem[] {
        // Limit by count
        const limitedMemories = memories.slice(0, this.MAX_MEMORIES)

        // Limit by storage size
        let totalSize = 0
        const sizeFilteredMemories: MemoryItem[] = []

        for (const memory of limitedMemories) {
            const memorySize = JSON.stringify(memory).length
            if (totalSize + memorySize <= this.STORAGE_LIMIT) {
                sizeFilteredMemories.push(memory)
                totalSize += memorySize
            } else {
                break
            }
        }

        return sizeFilteredMemories
    }

    static calculateStorageUsage(memories: MemoryItem[]): number {
        return JSON.stringify(memories).length
    }

    private static generateMemoryId(): string {
        return `mem_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`
    }

    static buildMemoryContext(memories: MemoryItem[], maxMemories = 15): string {
        const relevantMemories = memories.sort((a, b) => b.importance - a.importance).slice(0, maxMemories)

        if (relevantMemories.length === 0) return ""

        const groupedMemories = this.groupMemoriesByCategory(relevantMemories)

        return Object.entries(groupedMemories)
            .map(([category, items]) => {
                const memoryList = items.map((m) => m.content).join("; ")
                return `${category.replace("_", " ")}: ${memoryList}`
            })
            .join("\n")
    }

    private static groupMemoriesByCategory(memories: MemoryItem[]): Record<string, MemoryItem[]> {
        return memories.reduce(
            (groups, memory) => {
                const category = memory.category || "other"
                if (!groups[category]) groups[category] = []
                groups[category].push(memory)
                return groups
            },
            {} as Record<string, MemoryItem[]>,
        )
    }

    // Check if message is a manual memory instruction
    static isManualMemoryInstruction(message: string): boolean {
        const memoryKeywords = [
            "remember that",
            "remember my",
            "remember i",
            "don't forget",
            "keep in mind",
            "note that",
            "my name is",
            "i am",
            "i'm",
            "call me",
        ]

        const lowerMessage = message.toLowerCase()
        return memoryKeywords.some((keyword) => lowerMessage.includes(keyword))
    }

    // Extract manual memory from user instruction
    static extractManualMemory(message: string, sessionId: string): MemoryItem | null {
        const lowerMessage = message.toLowerCase()

        // Extract name
        const namePatterns = [/my name is (\w+)/i, /i am (\w+)/i, /i'm (\w+)/i, /call me (\w+)/i]

        for (const pattern of namePatterns) {
            const match = message.match(pattern)
            if (match) {
                return {
                    id: this.generateMemoryId(),
                    content: `User's name is ${match[1]}`,
                    category: "personal_info",
                    importance: 9,
                    timestamp: new Date(),
                    autoGenerated: false,
                    sessionId,
                    messageContext: message.substring(0, 200),
                }
            }
        }

        // Extract general remember instructions
        const rememberPatterns = [
            /remember that (.+)/i,
            /remember my (.+)/i,
            /remember i (.+)/i,
            /don't forget (.+)/i,
            /keep in mind (.+)/i,
            /note that (.+)/i,
        ]

        for (const pattern of rememberPatterns) {
            const match = message.match(pattern)
            if (match) {
                return {
                    id: this.generateMemoryId(),
                    content: match[1].trim(),
                    category: "other",
                    importance: 8,
                    timestamp: new Date(),
                    autoGenerated: false,
                    sessionId,
                    messageContext: message.substring(0, 200),
                }
            }
        }

        return null
    }
}
