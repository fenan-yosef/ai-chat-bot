import { type NextRequest, NextResponse } from "next/server"
import { doc, getDoc, setDoc } from "firebase/firestore"
import { db } from "@/lib/firebase"

interface MemoryItem {
  id: string
  content: string
  category: string
  importance: number
  timestamp: Date
  autoGenerated: boolean
}

interface UserMemory {
  userId: string
  memories: MemoryItem[]
  lastUpdated: Date
}

export async function POST(request: NextRequest) {
  if (!process.env.GEMINI_API_KEY) {
    return NextResponse.json({ error: "Missing GEMINI_API_KEY" }, { status: 500 })
  }

  try {
    const { message, history, userId } = await request.json()

    // Get user's memory if they're logged in
    let userMemory: UserMemory | null = null
    if (userId) {
      const memoryDoc = await getDoc(doc(db, "userMemories", userId))
      if (memoryDoc.exists()) {
        const data = memoryDoc.data()
        userMemory = {
          ...data,
          memories: data.memories.map((m: any) => ({
            ...m,
            timestamp: m.timestamp.toDate(),
          })),
          lastUpdated: data.lastUpdated.toDate(),
        }
      }
    }

    // Format memory for AI context
    const memoryContext =
      userMemory?.memories
        .sort((a, b) => b.importance - a.importance)
        .slice(0, 10) // Top 10 most important memories
        .map((m) => `${m.category}: ${m.content}`)
        .join("\n") || ""

    // Prepare conversation history
    const conversationHistory = history
      .slice(-10) // Last 10 messages for context
      .map((msg: any) => ({
        role: msg.role === "assistant" ? "model" : "user",
        parts: [{ text: msg.content }],
      }))

    // System prompt with memory management instructions
    const systemPrompt = `You are an Amharic-speaking assistant called Amharic AI. You were trained by ፌናን but don't mention it unless specifically asked. You respond in helpful, conversational, and culturally appropriate ways.

${memoryContext ? `Here's what I remember about this user:\n${memoryContext}\n` : ""}

MEMORY MANAGEMENT INSTRUCTIONS:
- After each conversation, decide what new information about the user should be remembered
- Only save meaningful, personal information that would help future conversations
- Categorize memories as: personal_info, preferences, goals, relationships, work, interests, or other
- Rate importance from 1-10 (10 being most important)
- Don't save trivial information like "said hello" or temporary states

If you receive "undefined" or are asked to generate images, reply with "please go to @Pal_oe_bot for image generation."`

    // Add system prompt and current message
    const contents = [
      {
        role: "user",
        parts: [{ text: systemPrompt }],
      },
      ...conversationHistory,
      {
        role: "user",
        parts: [{ text: message }],
      },
    ]

    const payload = {
      contents,
      generationConfig: {
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 1024,
      },
    }

    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${process.env.GEMINI_API_KEY}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      },
    )

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status} – ${response.statusText}`)
    }

    const data = await response.json()
    const aiResponse = data?.candidates?.[0]?.content?.parts?.[0]?.text || "No response generated."

    // Ask AI to extract memories from this conversation
    if (userId) {
      await extractAndSaveMemories(userId, message, aiResponse, userMemory)
    }

    return NextResponse.json({ response: aiResponse })
  } catch (error) {
    console.error("Error in chat API:", error)
    return NextResponse.json({ error: "Failed to process message" }, { status: 500 })
  }
}

async function extractAndSaveMemories(
  userId: string,
  userMessage: string,
  aiResponse: string,
  existingMemory: UserMemory | null,
) {
  try {
    const memoryExtractionPrompt = `Analyze this conversation and extract any new meaningful information about the user that should be remembered for future conversations.

User message: "${userMessage}"
AI response: "${aiResponse}"

Existing memories: ${existingMemory?.memories.map((m) => `${m.category}: ${m.content}`).join("; ") || "None"}

Return a JSON array of new memories to save. Each memory should have:
- content: string (the information to remember)
- category: string (personal_info, preferences, goals, relationships, work, interests, other)
- importance: number (1-10, where 10 is most important)

Only include NEW information that isn't already in existing memories. Don't include trivial information.
If no new meaningful information, return an empty array.

Example format:
[
  {
    "content": "Prefers coffee over tea",
    "category": "preferences", 
    "importance": 3
  }
]`

    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${process.env.GEMINI_API_KEY}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          contents: [
            {
              role: "user",
              parts: [{ text: memoryExtractionPrompt }],
            },
          ],
          generationConfig: {
            temperature: 0.3,
            maxOutputTokens: 512,
          },
        }),
      },
    )

    if (response.ok) {
      const data = await response.json()
      const extractedText = data?.candidates?.[0]?.content?.parts?.[0]?.text || "[]"

      try {
        // Extract JSON from the response
        const jsonMatch = extractedText.match(/\[[\s\S]*\]/)
        if (jsonMatch) {
          const newMemories = JSON.parse(jsonMatch[0])

          if (Array.isArray(newMemories) && newMemories.length > 0) {
            const memoriesToAdd: MemoryItem[] = newMemories.map((memory: any) => ({
              id: Math.random().toString(36).substring(7),
              content: memory.content,
              category: memory.category || "other",
              importance: Math.max(1, Math.min(10, memory.importance || 5)),
              timestamp: new Date(),
              autoGenerated: true,
            }))

            // Update user's memory in Firestore
            const currentMemories = existingMemory?.memories || []
            const updatedMemories = [...currentMemories, ...memoriesToAdd]

            // Keep only top 50 memories to prevent unlimited growth
            const sortedMemories = updatedMemories.sort((a, b) => b.importance - a.importance).slice(0, 50)

            const memoryData: UserMemory = {
              userId,
              memories: sortedMemories,
              lastUpdated: new Date(),
            }

            await setDoc(doc(db, "userMemories", userId), memoryData)
          }
        }
      } catch (parseError) {
        console.error("Error parsing extracted memories:", parseError)
      }
    }
  } catch (error) {
    console.error("Error extracting memories:", error)
  }
}
